// BTCP USAGE EXAMPLE
// USING BSSR GEN X TCP PROTOCOL
// We'll be using this protocol for GEN11 as well.
// These are just code fragments, copy and paste them into appropriate spots in program.
// some code is taken directly from bssr's gen x mcmb code, make sure to check that out once you understand how to transmit/receive data thru btcp
​
/*===================== SETTING THINGS UP =====================*/
​
// MAKE SURE btcp.c AND buart.c FILES ARE IN /Src DIRECTORY.
// MAKE SURE btcp.h AND buart.h FILES ARE IN /Inc DIRECTORY.
​
/* Includes */
// INCLUDE THESE TWO HEADERS IN ORDER TO USE BSSR'S TCP PROTOCOL
#include "buart.h"
#include "btcp.h"
​
/* Private Defines */
// for bitwise operations later on
#define MOTOR 16
#define FWD_REV 8
#define VFM_UP 4
#define VFM_DOWN 2
#define VFM_RESET 1
​
/* Private Variables */
//These three lines can be autogenerated by CubeMX
CRC_HandleTypeDef hcrc;
UART_HandleTypeDef huartA;
UART_HandleTypeDef huartB;
​
// TO TRANSMIT USING BSSR TCP PROTOCOL,
B_uartHandle_t *rxBuart;
B_uartHandle_t *txBuart;
B_tcpHandle_t *btcp;
​
// define some variables that will hold the important data you need
// for receiving data only.
uint8_t accValue = 0;
uint8_t regenValue = 0;
uint8_t motorState = 0;
uint8_t vfmUpState = 0;
uint8_t fwdRevState = 0;
uint8_t vfmDownState = 0;
uint8_t vfmResetState = 0;
long lastDcmbPacket = 0;
​
/* Private Function Prototypes */
// Define this function exactly as is. will explain what this function does later when it's properly defined.
void serialParse(B_tcpPacket_t *pkt);
​
/* Initialization */
// MUST INITIALIZE THESE HANDLES BEFORE TRANSMITTING ANYTHING USING THEM.
// this will create uart tx and rx tasks that will always be running throughout the program.
rxBuart = B_uartStart(&huartA);
txBuart = B_uartStart(&huartB);
​
// Next, initialize the btcp handle using B_tcpStart
// This will also create a Task that will be constantly looking for received data
// First parameter can be replaced with a pointer to an array of txBuarts if you want to transmit from multiple uart pins at once
btcp = B_tcpStart(/*transmitBuarts=*/ &txBuart, /*rxBuart=*/ rxBuart, /*numTransmitBuarts=*/ 1, &hcrc);
​
/* Main Program/Default Task */
/*===================== SENDING DATA =====================*/
​
// First we need to define the data that is to be sent.
// payload can be up to 255 bytes long. we'll transmit 4 bytes in this case. easiest way to transmit is to define an array of bytes.
uint8_t payload[4] = {0x00, 0x00, 0x00, 0x00};
​
// according to the protocol, the first byte of the payload must be the data identifier. This helps specify what kind of data is in the payload.
// refer to GenX socket protocol for details on which data ID and sender address to use.
// you could hard-code the data identifier or have a macro somewhere for it.
buf[0] = 0x03; // data ID for MCMB, as specified in protocol, assuming that it's the MCMB that's sending the data...
​
// fill the rest of the bytes with whatever useful data you want to send.
buf[1] = 0xAA;
buf[2] = 0xAA;
buf[3] = 0xAA;
​
// Now that payload has the data we want to send, call B_tcpSend() to transmit data
// 1st parameter is pointer B_tcpHandle_t. 
// 2nd parameter is pointer to buffer (uint8_t array). 
// 3rd parameter is a uint8_t whose value is how many bytes of data we are sending.
B_tcpSend(btcp, payload, 4);
​
/* Function Definitions */
/*===================== RECEIVING DATA =====================*/
// For receiving data, you need to define a function called serialParse() that takes a B_tcpPacket_t* as its only parameter, like so:
// in this function is where you will store data from the received tcpPacket to variables of your choice.
// This function will be called by the btcp rx tasks
// Adapted from main.c of GenX MCMB firmware
void serialParse(B_tcpPacket_t *pkt){
	switch(pkt->sender){ // decide what to do based on what sender address is received
		case 0x04:
			if(pkt->payload[4] == 0x00){
				// load values from payload in tcp packet to variables for use in program
				// im not too sure how the payload will exactly be formatted, it will depend on what you program your nucleo to do.
				// i just pasted what's in the main.c of genx mcmb here as placeholder.
				accValue = pkt->payload[6];
		  		regenValue = pkt->payload[7];
		  		motorState = pkt->payload[5] & MOTOR;
	   	  		fwdRevState = pkt->payload[5] & FWD_REV;
	   	  		vfmDownState = pkt->payload[5] & VFM_DOWN;
	   	  		vfmUpState = pkt->payload[5] & VFM_UP;
	   	  		lastDcmbPacket = xTaskGetTickCount();
			}
	}
}